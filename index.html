<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chapter 12 — Surface Areas & Volumes (Class 10) — Interactive</title>

<!-- anime.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

<!-- minimal Tailwind-like utility (tiny) -->
<style>
  :root{
    --bg:#071026; --card:#072033cc; --muted:#98a8b3; --accent:#7c5cff; --accent2:#00d4ff;
    --success:#34d399; --danger:#fb7185;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,var(--bg),#02111b);color:#e6eef6;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;min-height:100vh}
  .app{display:flex;gap:16px;padding:18px}
  .sidebar{width:300px;flex:0 0 300px;position:sticky;top:18px;height:calc(100vh - 36px)}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(2,6,23,0.7)}
  .title{font-size:18px;font-weight:700;color:var(--accent)}
  .muted{color:var(--muted);font-size:13px}
  .nav{margin-top:12px;display:flex;flex-direction:column;gap:8px}
  .nav button{background:transparent;border:1px solid rgba(255,255,255,0.03);color:#cfe7ff;padding:10px;border-radius:8px;text-align:left;cursor:pointer}
  .nav button.active{background:linear-gradient(90deg, rgba(124,92,255,0.12), rgba(0,212,255,0.06));border-color:rgba(124,92,255,0.26)}
  main{flex:1;overflow:auto;padding-bottom:40px}
  section{margin-bottom:20px}
  .section-header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .h2{font-size:16px;color:var(--accent);font-weight:700}
  .desc{color:var(--muted);font-size:13px;margin-top:6px}
  .grid{display:grid;grid-template-columns:1fr 380px;gap:12px;margin-top:12px}
  .sim-area{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border-radius:10px;padding:12px;min-height:320px;border:1px solid rgba(255,255,255,0.02)}
  .controls{display:flex;flex-direction:column;gap:10px}
  label{font-size:13px;color:#dbeafe;display:flex;flex-direction:column;gap:6px}
  input[type=range]{width:100%}
  .val{font-weight:700;color:var(--accent2)}
  .formula{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-family:ui-monospace,monospace;color:#dbeafe}
  .bignum{font-size:20px;font-weight:700;color:#cfeffd}
  .btn{padding:8px 10px;border-radius:8px;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#001018;border:none;cursor:pointer}
  .secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:#cfeffd}
  .footer{margin-top:8px;color:var(--muted);font-size:12px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:12px}
  .canvas-wrap{display:flex;align-items:center;justify-content:center;height:340px}
  .stat{margin-top:10px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
  .row{display:flex;gap:8px;align-items:center}
  .hint{color:var(--muted);font-size:13px}
  @media (max-width:980px){
    .app{flex-direction:column;padding:12px}
    .sidebar{width:100%;height:auto;position:relative}
    .grid{grid-template-columns:1fr;gap:10px}
    .nav{flex-direction:row;flex-wrap:wrap}
    .nav button{flex:1 1 48%}
  }
  @media (prefers-reduced-motion: reduce){
    *{animation:none!important;transition:none!important}
  }
</style>
</head>
<body>
<div class="app">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="card">
      <div class="title">Chapter 12 — Surface Areas & Volumes</div>
      <div class="muted" style="margin-top:6px">Class 10 NCERT — Interactive simulations. Move sliders, rotate shapes, see formulas update live. Built with <span class="badge">anime.js</span></div>
      <div class="nav" role="navigation" aria-label="Chapter sections" id="nav">
        <button data-target="cuboid" class="active">1 • Cubes & Cuboids</button>
        <button data-target="sphere">2 • Sphere</button>
        <button data-target="cylinder">3 • Cylinder</button>
        <button data-target="cone">4 • Cone</button>
        <button data-target="frustum">5 • Frustum</button>
        <button data-target="apps">6 • Applications & Problems</button>
      </div>

      <div style="margin-top:12px" class="muted">
        <div><strong>Progress:</strong> <span id="progressPct">0 / 6</span></div>
        <div class="footer">Saved locally. Respect reduced motion settings.</div>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px">
        <button id="resetProgress" class="secondary" style="flex:1"></button>
        <button id="downloadJSON" class="secondary" style="flex:1"></button>
      </div>
    </div>
  </aside>

  <!-- Main -->
  <main>
    <!-- Cuboid -->
    <section id="cuboid" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Cubes & Cuboids</div>
          <div class="desc">Surface area (TSA) & Volume. Change length, breadth, height — watch shape animate and formulas update.</div>
        </div>
        <div class="badge">TSA = 2(lb + bh + hl) • V = lbh</div>
      </div>

      <div class="grid">
        <div class="sim-area">
          <div class="canvas-wrap">
            <svg id="cuboidSVG" width="560" height="320" viewBox="0 0 560 320" aria-label="Cuboid simulation"></svg>
          </div>
          <div class="stat" id="cuboidStats" aria-live="polite">
            <div class="row"><div class="muted">Dimensions:</div><div class="val" id="dim-l">l=2.0</div><div class="val" id="dim-b">b=1.5</div><div class="val" id="dim-h">h=1.2</div></div>
            <div style="margin-top:8px" class="row"><div class="muted">TSA:</div><div class="bignum" id="cuboidTSA">—</div></div>
            <div class="row"><div class="muted">Volume:</div><div class="bignum" id="cuboidVol">—</div></div>
          </div>
        </div>

        <div class="controls card">
          <label>Length (l): <span class="val" id="lVal">2.0</span>
            <input id="lRange" type="range" min="0.5" max="8" step="0.1" value="2">
          </label>
          <label>Breadth (b): <span class="val" id="bVal">1.5</span>
            <input id="bRange" type="range" min="0.5" max="8" step="0.1" value="1.5">
          </label>
          <label>Height (h): <span class="val" id="hVal">1.2</span>
            <input id="hRange" type="range" min="0.5" max="8" step="0.1" value="1.2">
          </label>

          <div style="display:flex;gap:8px;margin-top:10px">
            <button id="cuboidRotate" class="btn">Rotate</button>
            <button id="cuboidExplode" class="secondary">Explode (faces)</button>
          </div>

          <div style="margin-top:12px">
            <div class="formula">TSA = 2(l b + b h + h l) = <span id="cuboidTSAformula">—</span></div>
            <div class="formula" style="margin-top:8px">V = l × b × h = <span id="cuboidVformula">—</span></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Sphere -->
    <section id="sphere" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Spheres</div>
          <div class="desc">Surface area & volume of a sphere. Try changing the radius and filling level.</div>
        </div>
        <div class="badge">SA = 4πr² • V = (4/3)πr³</div>
      </div>

      <div class="grid">
        <div class="sim-area">
          <div class="canvas-wrap">
            <canvas id="sphereCanvas" width="560" height="320" aria-label="Sphere"></canvas>
          </div>

          <div class="stat" id="sphereStats" aria-live="polite">
            <div class="row"><div class="muted">Radius: <span class="val" id="rVal">1.5</span> units</div></div>
            <div style="margin-top:8px" class="row"><div class="muted">Surface Area:</div><div class="bignum" id="sphereSA">—</div></div>
            <div class="row"><div class="muted">Volume:</div><div class="bignum" id="sphereVol">—</div></div>
          </div>
        </div>

        <div class="controls card">
          <label>Radius (r): <span class="val" id="rSliderVal">1.5</span>
            <input id="rRange" type="range" min="0.5" max="6" step="0.1" value="1.5">
          </label>

          <label>Fill %: <span class="val" id="fillVal">0%</span>
            <input id="fillRange" type="range" min="0" max="100" step="1" value="0">
          </label>

          <div style="margin-top:8px">
            <div class="formula">SA = 4π r² = <span id="sphereSAformula">—</span></div>
            <div class="formula" style="margin-top:8px">V = (4/3)π r³ = <span id="sphereVformula">—</span></div>
          </div>

          <div style="margin-top:12px" class="hint">Tip: Fill % animates a liquid level inside the sphere to visualize volume fraction.</div>
        </div>
      </div>
    </section>

    <!-- Cylinder -->
    <section id="cylinder" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Right Circular Cylinder</div>
          <div class="desc">Curved surface area (CSA), total surface area & volume. Try unrolling the lateral surface.</div>
        </div>
        <div class="badge">CSA = 2π r h • TSA = 2π r (r + h)</div>
      </div>

      <div class="grid">
        <div class="sim-area">
          <div class="canvas-wrap">
            <svg id="cylSVG" width="560" height="320" viewBox="0 0 560 320" aria-label="Cylinder"></svg>
          </div>
          <div class="stat" id="cylStats" aria-live="polite">
            <div class="row"><div class="muted">Radius:</div><div class="val" id="cylR">1.0</div><div class="muted">Height:</div><div class="val" id="cylH">2.0</div></div>
            <div style="margin-top:8px" class="row"><div class="muted">CSA:</div><div class="bignum" id="cylCSA">—</div></div>
            <div class="row"><div class="muted">Volume:</div><div class="bignum" id="cylVol">—</div></div>
          </div>
        </div>

        <div class="controls card">
          <label>Radius (r): <span class="val" id="cylRVal">1.0</span>
            <input id="cylRRange" type="range" min="0.5" max="5" step="0.1" value="1">
          </label>
          <label>Height (h): <span class="val" id="cylHVal">2.0</span>
            <input id="cylHRange" type="range" min="0.5" max="8" step="0.1" value="2">
          </label>

          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="unrollCyl" class="btn">Unroll Lateral Surface</button>
            <button id="cylRotate" class="secondary">Rotate</button>
          </div>

          <div style="margin-top:12px">
            <div class="formula">CSA = 2π r h = <span id="cylCSAformula">—</span></div>
            <div class="formula" style="margin-top:8px">V = π r² h = <span id="cylVformula">—</span></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Cone -->
    <section id="cone" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Cone</div>
          <div class="desc">Curved surface area & volume. Unfold curved surface to a sector to understand CSA.</div>
        </div>
        <div class="badge">CSA = π r l • V = (1/3)π r² h</div>
      </div>

      <div class="grid">
        <div class="sim-area">
          <div class="canvas-wrap">
            <svg id="coneSVG" width="560" height="320" viewBox="0 0 560 320" aria-label="Cone"></svg>
          </div>
          <div class="stat" id="coneStats" aria-live="polite">
            <div class="row"><div class="muted">Radius:</div><div class="val" id="coneR">1.0</div><div class="muted">Height:</div><div class="val" id="coneH">2.0</div></div>
            <div style="margin-top:8px" class="row"><div class="muted">Slant height (l):</div><div class="bignum" id="coneL">—</div></div>
            <div class="row"><div class="muted">CSA:</div><div class="bignum" id="coneCSA">—</div></div>
            <div class="row"><div class="muted">Volume:</div><div class="bignum" id="coneVol">—</div></div>
          </div>
        </div>

        <div class="controls card">
          <label>Radius (r): <span class="val" id="coneRVal">1.0</span>
            <input id="coneRRange" type="range" min="0.5" max="5" step="0.1" value="1">
          </label>
          <label>Height (h): <span class="val" id="coneHVal">2.0</span>
            <input id="coneHRange" type="range" min="0.5" max="8" step="0.1" value="2">
          </label>

          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="unfoldCone" class="btn">Unfold Curved Surface</button>
            <button id="coneRotate" class="secondary">Rotate</button>
          </div>

          <div style="margin-top:12px">
            <div class="formula">l = √(r² + h²) = <span id="coneLformula">—</span></div>
            <div class="formula" style="margin-top:8px">CSA = π r l = <span id="coneCSAformula">—</span></div>
            <div class="formula" style="margin-top:8px">V = (1/3)π r² h = <span id="coneVformula">—</span></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Frustum -->
    <section id="frustum" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Frustum of a Cone</div>
          <div class="desc">Curved surface area and volume of frustum formed by slicing a cone.</div>
        </div>
        <div class="badge">V = (1/3)π h (R² + Rr + r²) • CSA = π (R + r) s</div>
      </div>

      <div class="grid">
        <div class="sim-area">
          <div class="canvas-wrap">
            <svg id="frustumSVG" width="560" height="320" viewBox="0 0 560 320" aria-label="Frustum"></svg>
          </div>
          <div class="stat" id="frustumStats" aria-live="polite">
            <div class="row"><div class="muted">Top r:</div><div class="val" id="frR">0.8</div><div class="muted">Bottom R:</div><div class="val" id="frRbig">2.0</div><div class="muted">Height h:</div><div class="val" id="frH">2.0</div></div>
            <div style="margin-top:8px" class="row"><div class="muted">Slant (s):</div><div class="bignum" id="frS">—</div></div>
            <div class="row"><div class="muted">CSA:</div><div class="bignum" id="frCSA">—</div></div>
            <div class="row"><div class="muted">Volume:</div><div class="bignum" id="frVol">—</div></div>
          </div>
        </div>

        <div class="controls card">
          <label>Top radius (r): <span class="val" id="frRval">0.8</span>
            <input id="frRRange" type="range" min="0.2" max="4" step="0.1" value="0.8">
          </label>
          <label>Bottom radius (R): <span class="val" id="frRbigval">2.0</span>
            <input id="frRbigRange" type="range" min="0.5" max="5" step="0.1" value="2.0">
          </label>
          <label>Height (h): <span class="val" id="frHval">2.0</span>
            <input id="frHRange" type="range" min="0.5" max="6" step="0.1" value="2.0">
          </label>

          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="sliceFrustum" class="btn">Slice from Cone</button>
            <button id="frRotate" class="secondary">Rotate</button>
          </div>

          <div style="margin-top:12px">
            <div class="formula">s = √(h² + (R − r)²) = <span id="frSformula">—</span></div>
            <div class="formula" style="margin-top:8px">CSA = π (R + r) s = <span id="frCSAformula">—</span></div>
            <div class="formula" style="margin-top:8px">V = (1/3)π h (R² + Rr + r²) = <span id="frVformula">—</span></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Applications -->
    <section id="apps" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Applications & Problems</div>
          <div class="desc">Real-world problems: water tank (cylinder), ice-cream cone (cone+hemisphere), dome (hemisphere).</div>
        </div>
        <div class="badge">Solve step-by-step. Click examples to view worked solution.</div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px">
        <div class="card" style="padding:12px">
          <div style="font-weight:700">Example 1 — Water Tank</div>
          <div class="muted" style="margin-top:6px">A cylindrical tank radius 2m and height 3m. Find capacity and total surface area.</div>
          <div style="margin-top:10px;display:flex;gap:8px">
            <button class="btn" id="solveTank">Show solution</button>
            <button class="secondary" id="resetTank">Reset</button>
          </div>
          <div id="tankSolution" style="margin-top:10px;color:var(--muted)"></div>
        </div>

        <div class="card" style="padding:12px">
          <div style="font-weight:700">Example 2 — Ice-cream Cone</div>
          <div class="muted" style="margin-top:6px">Cone radius 3cm height 4cm with hemisphere of radius 3cm. Find volume.</div>
          <div style="margin-top:10px;display:flex;gap:8px">
            <button class="btn" id="solveIce">Show solution</button>
          </div>
          <div id="iceSolution" style="margin-top:10px;color:var(--muted)"></div>
        </div>
      </div>
    </section>

    <div style="height:60px"></div>
  </main>
</div>

<script>
/*
  Interactive Chapter 12 SPA
  - Uses anime.js for animations
  - Draws shapes in SVG / Canvas and updates formulas live
  - Saves progress to localStorage
  - Respects prefers-reduced-motion
*/

// Utilities
const el = id => document.getElementById(id);
const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
const saved = (k, def) => {
  try { const s = JSON.parse(localStorage.getItem('ch12_'+k)); return s ?? def } catch(e) { return def }
};
const save = (k,v) => localStorage.setItem('ch12_'+k, JSON.stringify(v));
const isReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

// Progress tracking
let completed = saved('completed', {});
function markDone(section) { completed[section]=true; save('completed', completed); updateProgressUI(); }
function updateProgressUI(){
  const total = 6;
  const done = Object.keys(completed).length;
  el('progressPct').textContent = done + ' / ' + total;
}
updateProgressUI();

// NAV: scroll to section behavior + active class
document.querySelectorAll('.nav button').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const tgt = btn.dataset.target;
    document.getElementById(tgt).scrollIntoView({behavior: isReducedMotion ? 'auto' : 'smooth', block:'start'});
    document.querySelectorAll('.nav button').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
  });
});

// Reset & export
el('resetProgress').addEventListener('click', ()=>{
  if (!confirm('Reset saved progress?')) return;
  localStorage.clear();
  completed = {};
  updateProgressUI();
  location.reload();
});
el('downloadJSON').addEventListener('click', ()=>{
  const data = {completed, timestamp: new Date().toISOString()};
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='ch12-progress.json'; a.click();
});

/* --------------------
   CUBOID (SVG drawing & interactions)
   -------------------- */
const cuboidSVG = el('cuboidSVG');
const NS = "http://www.w3.org/2000/svg";
function createSVG(tag, attrs){
  const node = document.createElementNS(NS, tag);
  for(const k in attrs) node.setAttribute(k, attrs[k]);
  return node;
}
function drawCuboid(l,b,h, opts={rotate:0}){
  // we'll use simple oblique projection to draw a rectangular solid
  cuboidSVG.innerHTML = '';
  const W=560, H=320;
  // scale to display
  const scale = 30; // px per unit
  const ox = 120, oy = 220;
  // base rectangle points
  const A = {x:ox, y:oy};
  const B = {x:ox + l*scale, y:oy};
  const D = {x:ox, y: oy - h*scale};
  const C = {x:ox + l*scale, y: oy - h*scale};
  // offset for depth (breadth)
  const dx = b*scale*0.6;
  const dy = -b*scale*0.4;
  const A2 = {x:A.x + dx, y: A.y + dy};
  const B2 = {x:B.x + dx, y: B.y + dy};
  const D2 = {x:D.x + dx, y: D.y + dy};
  const C2 = {x:C.x + dx, y: C.y + dy};

  // faces: draw back (A2,B2,C2,D2), top (D2,C2,C,D), front (A,B,C,D), side (B,B2,C2,C)
  // back face (slightly translucent)
  cuboidSVG.appendChild(createSVG('polygon',{points:`${A2.x},${A2.y} ${B2.x},${B2.y} ${C2.x},${C2.y} ${D2.x},${D2.y}`, fill:'rgba(124,92,255,0.08)', stroke:'rgba(124,92,255,0.18)', 'stroke-width':1}));
  // top face
  cuboidSVG.appendChild(createSVG('polygon',{points:`${D2.x},${D2.y} ${C2.x},${C2.y} ${C.x},${C.y} ${D.x},${D.y}`, fill:'rgba(0,212,255,0.06)', stroke:'rgba(0,212,255,0.12)', 'stroke-width':1}));
  // front face
  cuboidSVG.appendChild(createSVG('polygon',{points:`${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`, fill:'rgba(255,255,255,0.02)', stroke:'rgba(255,255,255,0.06)', 'stroke-width':1}));
  // edges
  [A,B,C,D,A2,B2,C2,D2].forEach(pt=>{
    cuboidSVG.appendChild(createSVG('circle',{cx:pt.x, cy:pt.y, r:0.8, fill:'rgba(255,255,255,0.06)'}));
  });

  // highlight edges with gradient lines for style
  cuboidSVG.appendChild(createSVG('polyline',{points:`${A.x},${A.y} ${A2.x},${A2.y} ${B2.x},${B2.y} ${B.x},${B.y}`, fill:'none', stroke:'rgba(124,92,255,0.22)', 'stroke-width':2}));
  // label dims
  const label = createSVG('text', { x: 20, y: 20, fill: '#cfeffd', 'font-size': 12 });
label.textContent = '';
cuboidSVG.appendChild(label);


  label.textContent = '';
  cuboidSVG.appendChild(label);
}

// initial cuboid state
let L = parseFloat(el('lRange').value);
let B = parseFloat(el('bRange').value);
let H = parseFloat(el('hRange').value);

function updateCuboidUI(){
  el('lVal').textContent = L.toFixed(1);
  el('bVal').textContent = B.toFixed(1);
  el('hVal').textContent = H.toFixed(1);
  // calculations
  const tsa = 2*(L*B + B*H + H*L);
  const vol = L*B*H;
  el('cuboidTSA').textContent = tsa.toFixed(3);
  el('cuboidVol').textContent = vol.toFixed(3);
  el('cuboidTSAformula').textContent = tsa.toFixed(3);
  el('cuboidVformula').textContent = vol.toFixed(3);
  el('dim-l').textContent = 'l=' + L.toFixed(2);
  el('dim-b').textContent = 'b=' + B.toFixed(2);
  el('dim-h').textContent = 'h=' + H.toFixed(2);
  drawCuboid(L,B,H);
  markDone('cuboid');
}
el('lRange').addEventListener('input', e=>{ L = parseFloat(e.target.value); el('lVal').textContent = L.toFixed(1); updateCuboidUI();});
el('bRange').addEventListener('input', e=>{ B = parseFloat(e.target.value); el('bVal').textContent = B.toFixed(1); updateCuboidUI();});
el('hRange').addEventListener('input', e=>{ H = parseFloat(e.target.value); el('hVal').textContent = H.toFixed(1); updateCuboidUI();});

el('cuboidRotate').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  anime({
    targets: '#cuboidSVG polygon',
    rotate: [
      { value: 5, duration: 300 },
      { value: -5, duration: 300 },
      { value: 0, duration: 300 }
    ],
    easing: 'easeInOutQuad'
  });
});
el('cuboidExplode').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  // quick scale-pulse to give "explode" feel
  anime({
    targets: '#cuboidSVG polygon',
    translateX: (el, i) => (i%2===0? -10 : 10),
    translateY: (el, i) => (i%2===0? -6 : 6),
    duration: 700,
    direction:'alternate',
    easing:'easeInOutQuad'
  });
});
updateCuboidUI();

/* --------------------
   SPHERE (Canvas drawing, fill animation)
   -------------------- */
const sphereCanvas = el('sphereCanvas');
const sCtx = sphereCanvas.getContext('2d');
let r = parseFloat(el('rRange').value);
let fillPct = parseInt(el('fillRange').value,10);

function drawSphere(){
  const W = sphereCanvas.width, H = sphereCanvas.height;
  sCtx.clearRect(0,0,W,H);
  // center
  const cx = W/2, cy = H/2;
  const px = 40; // pixels per unit
  const rad = r * px;
  // draw gradient sphere
  const grad = sCtx.createRadialGradient(cx - rad*0.3, cy - rad*0.4, rad*0.1, cx, cy, rad);
  grad.addColorStop(0, 'rgba(255,255,255,0.9)');
  grad.addColorStop(0.5, 'rgba(124,92,255,0.6)');
  grad.addColorStop(1, 'rgba(0,212,255,0.12)');
  sCtx.fillStyle = grad;
  sCtx.beginPath(); sCtx.arc(cx, cy, rad, 0, Math.PI*2); sCtx.fill();

  // outline
  sCtx.strokeStyle = 'rgba(255,255,255,0.06)';
  sCtx.lineWidth = 2; sCtx.beginPath(); sCtx.arc(cx,cy,rad,0,Math.PI*2); sCtx.stroke();

  // draw highlight ellipse for rotation illusion
  sCtx.fillStyle = 'rgba(255,255,255,0.06)';
  sCtx.beginPath(); sCtx.ellipse(cx - rad*0.25, cy - rad*0.45, rad*0.28, rad*0.12, 0, 0, Math.PI*2); sCtx.fill();

  // draw fill (liquid) as clipped arc according to fillPct
  if (fillPct > 0) {
    // compute volume fraction ~= proportion of sphere height filled: v_frac = ? approximate by cap height hcap
    const frac = fillPct / 100;
    // find cap height 'hcap' that yields volume fraction frac (approx solve numerically)
    const R = rad;
    // We'll find capHeight (in pixels) from 0..2R
    let lo=0, hi=2*R, mid;
    const sphereVolume = (4/3)*Math.PI*Math.pow(R,3);
    for(let i=0;i<40;i++){
      mid = (lo+hi)/2;
      const hcap = mid;
      // volume of spherical cap of height hcap (measured from top) = π hcap² (R - hcap/3)
      const capVol = Math.PI * Math.pow(hcap,2) * (R - hcap/3);
      if (capVol / sphereVolume > frac) hi = mid; else lo = mid;
    }
    const hcap = mid;
    // draw cap starting from top = cy - R to a horizontal line at cy - R + hcap
    const clipY = cy - R + hcap;
    sCtx.save();
    sCtx.beginPath();
    sCtx.rect(0, clipY, W, H - clipY);
    sCtx.clip();
    // liquid gradient
    const lg = sCtx.createLinearGradient(0, clipY, 0, H);
    lg.addColorStop(0, 'rgba(0,200,255,0.35)');
    lg.addColorStop(1, 'rgba(0,60,120,0.15)');
    sCtx.fillStyle = lg;
    sCtx.beginPath(); sCtx.arc(cx, cy, R, 0, Math.PI*2); sCtx.fill();
    sCtx.restore();
  }

  // update stats
  const sa = 4*Math.PI*Math.pow(r,2);
  const vol = 4/3*Math.PI*Math.pow(r,3);
  el('sphereSA').textContent = sa.toFixed(3);
  el('sphereVol').textContent = vol.toFixed(3);
  el('sphereSAformula').textContent = sa.toFixed(3);
  el('sphereVformula').textContent = vol.toFixed(3);
  el('rVal').textContent = r.toFixed(2);
  el('rSliderVal').textContent = r.toFixed(2);
  el('fillVal').textContent = fillPct + '%';
  markDone('sphere');
}

el('rRange').addEventListener('input', e=>{ r = parseFloat(e.target.value); drawSphere(); });
el('fillRange').addEventListener('input', e=>{ fillPct = parseInt(e.target.value,10); if (!isReducedMotion) animateFill(fillPct); else { drawSphere(); } });

function animateFill(targetPct){
  anime({
    targets: {v: fillPct},
    v: targetPct,
    round: 1,
    duration: 800,
    easing: 'easeInOutCubic',
    update: anim => {
      fillPct = anim.animations[0].currentValue;
      drawSphere();
    }
  });
}
drawSphere();

/* --------------------
   Cylinder (SVG) + unroll animation
   -------------------- */
const cylSVG = el('cylSVG');

function drawCylinder(r,h){
  cylSVG.innerHTML = '';
  // draw top ellipse, body, bottom ellipse (simple perspective)
  const cx = 200, cy = 90;
  const a = 120; // width scale
  const ry = 20; // ellipse height
  const scale = 40;
  const R = r*scale, H = h*scale;

  // body rect
  const topY = cy; const botY = cy + H;
  // top ellipse
  cylSVG.appendChild(createSVG('ellipse',{cx:cx, cy:topY, rx:R, ry:ry, fill:'rgba(124,92,255,0.08)', stroke:'rgba(124,92,255,0.18)'}));
  // body rectangle (as path with top and bottom arcs)
  const rectPath = `M ${cx-R} ${topY} L ${cx-R} ${botY} A ${R} ${ry} 0 0 0 ${cx+R} ${botY} L ${cx+R} ${topY} A ${R} ${ry} 0 0 0 ${cx-R} ${topY}`;
  cylSVG.appendChild(createSVG('path',{d:rectPath, fill:'rgba(0,212,255,0.02)', stroke:'rgba(255,255,255,0.03)'}));
  // bottom ellipse (dashed to indicate hidden)
  cylSVG.appendChild(createSVG('ellipse',{cx:cx, cy:botY, rx:R, ry:ry, fill:'rgba(0,212,255,0.03)', stroke:'rgba(0,212,255,0.08)'}));

  // side edge lines
  cylSVG.appendChild(createSVG('line',{x1:cx-R, y1:topY, x2:cx-R, y2:botY, stroke:'rgba(124,92,255,0.12)'}));
  cylSVG.appendChild(createSVG('line',{x1:cx+R, y1:topY, x2:cx+R, y2:botY, stroke:'rgba(124,92,255,0.12)'}));

  // label
  cylSVG.appendChild(createSVG('text',{x:20,y:20,fill:'#cfeffd','font-size':12})).textContent = `Cylinder r=${r}, h=${h}`;
}

function updateCylinderUI(){
  const r = parseFloat(el('cylRRange').value);
  const h = parseFloat(el('cylHRange').value);
  drawCylinder(r,h);
  const csa = 2*Math.PI*r*h;
  const vol = Math.PI*r*r*h;
  el('cylCSA').textContent = csa.toFixed(3);
  el('cylVol').textContent = vol.toFixed(3);
  el('cylCSAformula').textContent = csa.toFixed(3);
  el('cylVformula').textContent = vol.toFixed(3);
  el('cylR').textContent = r.toFixed(2);
  el('cylH').textContent = h.toFixed(2);
  el('cylRVal').textContent = r.toFixed(2);
  el('cylHVal').textContent = h.toFixed(2);
  markDone('cylinder');
}
el('cylRRange').addEventListener('input', updateCylinderUI);
el('cylHRange').addEventListener('input', updateCylinderUI);
el('unrollCyl').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  // animate showing an unrolled rectangle to the right
  const svg = cylSVG;
  // create unrolled rect representation
  const W = 200, H = 120;
  const unroll = createSVG('rect',{x:320,y:80,width:220,height:120,fill:'rgba(124,92,255,0.06)',stroke:'rgba(124,92,255,0.16)',opacity:0});
  svg.appendChild(unroll);
  anime({
    targets: unroll,
    opacity: [0,1],
    translateX: [-40,0],
    duration: 800,
    easing: 'easeOutCubic',
    complete: ()=>{ setTimeout(()=>{ anime({targets: unroll, opacity:[1,0], duration:700, easing:'easeInCubic', complete: ()=>unroll.remove()}); }, 900); }
  });
});
el('cylRotate').addEventListener('click', ()=>{ if (isReducedMotion) return; anime({targets:'#cylSVG', rotate:[0,6,-6,0], duration:900, easing:'easeInOutQuad'}); });
updateCylinderUI();

/* --------------------
   CONE (SVG) + unfold
   -------------------- */
function drawCone(r,h){
  const svg = el('coneSVG');
  svg.innerHTML = '';
  const cx = 280, cy = 260;
  const scale = 30;
  const R = r*scale, H = h*scale;
  // draw cone (triangle + base ellipse)
  const left = cx - R, right = cx + R, apexX = cx, apexY = cy - H;
  const path = `M ${left} ${cy} L ${apexX} ${apexY} L ${right} ${cy} Z`;
  svg.appendChild(createSVG('path',{d:path, fill:'rgba(124,92,255,0.06)', stroke:'rgba(124,92,255,0.12)'}));
  svg.appendChild(createSVG('ellipse',{cx:cx, cy:cy, rx:R, ry: R*0.25, fill:'rgba(0,212,255,0.03)', stroke:'rgba(0,212,255,0.08)'}));
  // labels
  svg.appendChild(createSVG('text',{x:20,y:18,fill:'#cfeffd','font-size':12})).textContent = `Cone r=${r}, h=${h}`;
}
function updateConeUI(){
  const r = parseFloat(el('coneRRange').value);
  const h = parseFloat(el('coneHRange').value);
  drawCone(r,h);
  const l = Math.sqrt(r*r + h*h);
  const csa = Math.PI * r * l;
  const vol = (1/3) * Math.PI * r*r * h;
  el('coneL').textContent = l.toFixed(3);
  el('coneCSA').textContent = csa.toFixed(3);
  el('coneVol').textContent = vol.toFixed(3);
  el('coneLformula').textContent = l.toFixed(3);
  el('coneCSAformula').textContent = csa.toFixed(3);
  el('coneVformula').textContent = vol.toFixed(3);
  el('coneR').textContent = r.toFixed(2);
  el('coneH').textContent = h.toFixed(2);
  el('coneRVal').textContent = r.toFixed(2);
  el('coneHVal').textContent = h.toFixed(2);
  markDone('cone');
}
el('coneRRange').addEventListener('input', updateConeUI);
el('coneHRange').addEventListener('input', updateConeUI);

el('unfoldCone').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  // show a sector (unfold) with animated arc
  const svg = el('coneSVG');
  const rVal = parseFloat(el('coneRRange').value);
  const hVal = parseFloat(el('coneHRange').value);
  const l = Math.sqrt(rVal*rVal + hVal*hVal);
  const csa = Math.PI * rVal * l;
  const csaText = createSVG('text',{x:280,y:40,fill: 'var(--accent2)', 'font-size':16, 'text-anchor':'middle'});
  csaText.textContent = `Lateral Area ≈ ${csa.toFixed(2)}`;
  svg.appendChild(csaText);
  anime({ targets: csaText, opacity: [0,1], duration: 400, easing: 'linear', complete: () => {
      setTimeout(() => anime({ targets: csaText, opacity: [1,0], duration: 400, easing: 'linear', complete: () => csaText.remove() }), 1500);
  }});
  const sector = createSVG('path',{d:'', fill:'rgba(0,212,255,0.06)', stroke:'rgba(0,212,255,0.12)', opacity:0});
  svg.appendChild(sector);
  // compute sector arc angle = (circumference of base) / radius = 2πr / l
  const arcAngle = (2*Math.PI*rVal)/l;
  const Rpx = 120; // sector radius in px
  // create path for sector approximated
  const start = {x:280 + Rpx, y:160};
  const endX = start.x + Rpx*Math.cos(arcAngle);
  const endY = start.y + Rpx*Math.sin(arcAngle);
  const d = `M ${start.x} ${start.y} L ${start.x + Rpx} ${start.y} A ${Rpx} ${Rpx} 0 ${arcAngle>Math.PI?1:0} 0 ${endX} ${endY} Z`;
  sector.setAttribute('d', d);
  anime({
    targets: sector,
    opacity: [0,1],
    translateX: [-40,0],
    duration: 700,
    easing: 'easeOutCubic',
    complete: ()=> setTimeout(()=>anime({targets: sector, opacity:[1,0], duration:700, easing:'easeInCubic', complete: ()=>sector.remove()}), 1000)
  });
});
el('coneRotate').addEventListener('click', ()=>{ if (isReducedMotion) return; anime({targets:'#coneSVG', rotate:[0,6,-6,0], duration:900, easing:'easeInOutQuad'}); });
updateConeUI();

/* --------------------
   FRUSTUM
   -------------------- */
function drawFrustum(rSmall, rBig, h){
  const svg = el('frustumSVG');
  svg.innerHTML = '';
  const cx = 280, topY=80, botY=200;
  const scale = 40;
  const r1 = rSmall*scale, r2 = rBig*scale;
  const leftTop = cx - r1, rightTop = cx + r1;
  const leftBot = cx - r2, rightBot = cx + r2;
  // trapezoid sides + top and bottom ellipses
  const path = `M ${leftTop} ${topY} L ${leftBot} ${botY} L ${rightBot} ${botY} L ${rightTop} ${topY} Z`;
  svg.appendChild(createSVG('path',{d:path, fill:'rgba(124,92,255,0.06)', stroke:'rgba(124,92,255,0.12)'}));
  svg.appendChild(createSVG('ellipse',{cx:cx, cy:botY, rx:r2, ry: r2*0.25, fill:'rgba(0,212,255,0.03)', stroke:'rgba(0,212,255,0.06)'}));
  svg.appendChild(createSVG('ellipse',{cx:cx, cy:topY, rx:r1, ry: r1*0.25, fill:'rgba(255,255,255,0.02)', stroke:'rgba(255,255,255,0.04)'}));
}
function updateFrustumUI(){
  const r = parseFloat(el('frRRange').value);
  const R = parseFloat(el('frRbigRange').value);
  const h = parseFloat(el('frHRange').value);
  drawFrustum(r,R,h);
  const s = Math.sqrt(h*h + (R - r)*(R - r));
  const csa = Math.PI * (R + r) * s;
  const vol = (1/3) * Math.PI * h * (R*R + R*r + r*r);
  el('frS').textContent = s.toFixed(3);
  el('frCSA').textContent = csa.toFixed(3);
  el('frVol').textContent = vol.toFixed(3);
  el('frSformula').textContent = s.toFixed(3);
  el('frCSAformula').textContent = csa.toFixed(3);
  el('frVformula').textContent = vol.toFixed(3);
  el('frR').textContent = r.toFixed(2);
  el('frRbig').textContent = R.toFixed(2);
  el('frH').textContent = h.toFixed(2);
  el('frRval').textContent = r.toFixed(2);
  el('frRbigval').textContent = R.toFixed(2);
  el('frHval').textContent = h.toFixed(2);
  markDone('frustum');
}
el('frRRange').addEventListener('input', updateFrustumUI);
el('frRbigRange').addEventListener('input', updateFrustumUI);
el('frHRange').addEventListener('input', updateFrustumUI);
el('sliceFrustum').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  const svg = el('frustumSVG');
  const sl = createSVG('path',{d:'M10 10 H 200', stroke:'rgba(0,212,255,0.08)', 'stroke-width':2, opacity:0});
  svg.appendChild(sl);
  anime({targets: sl, opacity:[0,1], translateX:[-20,0], duration:700, easing:'easeOutCubic', complete: ()=>setTimeout(()=>anime({targets: sl, opacity:[1,0], duration:700, complete: ()=>sl.remove()}),800)});
});
el('frRotate').addEventListener('click', ()=>{ if (isReducedMotion) return; anime({targets:'#frustumSVG', rotate:[0,6,-6,0], duration:900, easing:'easeInOutQuad'}); });
updateFrustumUI();

/* --------------------
   Applications — Solutions for examples
   -------------------- */
el('solveTank').addEventListener('click', ()=>{
  const r = 2, h = 3; // meters
  const vol = Math.PI * r*r * h; // cubic meters
  const tsa = 2 * Math.PI * r * (r + h);
  el('tankSolution').innerHTML = `<div>Capacity (Volume) = π r² h = π × ${r}² × ${h} = ${vol.toFixed(3)} m³</div><div style="margin-top:6px">Total surface area = 2π r (r + h) = ${tsa.toFixed(3)} m²</div>`;
});
el('solveIce').addEventListener('click', ()=>{
  const r = 3, h = 4; // cm
  const volCone = (1/3) * Math.PI * r*r * h;
  const volSphereHalf = (2/3) * Math.PI * Math.pow(r,3);
  const total = volCone + volSphereHalf;
  el('iceSolution').innerHTML = `<div>Cone volume = (1/3)π r² h = ${(volCone).toFixed(2)} cm³</div>
    <div style="margin-top:6px">Hemisphere volume = (2/3)π r³ = ${(volSphereHalf).toFixed(2)} cm³</div>
    <div style="margin-top:8px"><strong>Total = ${total.toFixed(2)} cm³</strong></div>`;
});




/* --------------------
   Accessibility & small UX
   -------------------- */
// set tabindex + announce
document.querySelectorAll('.section').forEach(s=>{
  s.addEventListener('focusin', ()=> {
    // mark section visited
    markDone(s.id);
  });
});

// keyboard navigation: keys 1-6 jump to sections
document.addEventListener('keydown', e=>{
  if (e.ctrlKey || e.metaKey) return;
  const key = e.key;
  if (key >= '1' && key <= '6') {
    const idx = parseInt(key,10)-1;
    const btns = Array.from(document.querySelectorAll('.nav button'));
    if (btns[idx]) btns[idx].click();
  }


<!-- Continuing from Cylinder -->
// Cylinder interactions
let cylR = parseFloat(el('cylRRange').value);
let cylH = parseFloat(el('cylHRange').value);
function drawCylinder(r,h){
  cylSVG.innerHTML = '';
  const W=560,H=320,ox=280,oy=160;
  const px=40;
  const rx=r*px, hy=h*px;
  const topEllipse = `M${ox-rx},${oy-hy/2} a${rx},10 0 1,0 ${2*rx},0 a${rx},10 0 1,0 ${-2*rx},0`;
  const bottomEllipse = `M${ox-rx},${oy+hy/2} a${rx},10 0 1,0 ${2*rx},0 a${rx},10 0 1,0 ${-2*rx},0`;
  cylSVG.appendChild(createSVG('path',{d:topEllipse,stroke:'rgba(124,92,255,0.3)',fill:'rgba(124,92,255,0.08)','stroke-width':2}));
  cylSVG.appendChild(createSVG('path',{d:bottomEllipse,stroke:'rgba(0,212,255,0.2)',fill:'rgba(0,212,255,0.05)','stroke-width':2}));
  cylSVG.appendChild(createSVG('line',{x1:ox-rx,y1:oy-hy/2,x2:ox-rx,y2:oy+hy/2,stroke:'rgba(124,92,255,0.15)','stroke-width':2}));
  cylSVG.appendChild(createSVG('line',{x1:ox+rx,y1:oy-hy/2,x2:ox+rx,y2:oy+hy/2,stroke:'rgba(124,92,255,0.15)','stroke-width':2}));

  // update stats
  const csa = 2*Math.PI*r*h;
  const vol = Math.PI*r*r*h;
  el('cylCSA').textContent = csa.toFixed(3);
  el('cylVol').textContent = vol.toFixed(3);
  el('cylCSAformula').textContent = csa.toFixed(3);
  el('cylVformula').textContent = vol.toFixed(3);
  el('cylR').textContent = r.toFixed(2);
  el('cylH').textContent = h.toFixed(2);
  el('cylRVal').textContent = r.toFixed(2);
  el('cylHVal').textContent = h.toFixed(2);
  markDone('cylinder');
}
el('cylRRange').addEventListener('input', e=>{ cylR=parseFloat(e.target.value); drawCylinder(cylR,cylH); });
el('cylHRange').addEventListener('input', e=>{ cylH=parseFloat(e.target.value); drawCylinder(cylR,cylH); });
el('cylRotate').addEventListener('click', ()=>{ if(!isReducedMotion){ anime({targets:'#cylSVG',rotate:[0,15,-10,0],duration:1400,easing:'easeInOutSine'}); } });
el('unrollCyl').addEventListener('click', ()=>{ if(!isReducedMotion){ anime({targets:'#cylSVG path',scaleX:[1,1.5],direction:'alternate',duration:800,easing:'easeInOutQuad'}); }});
drawCylinder(cylR,cylH);

// Cone
let coneR = parseFloat(el('coneRRange').value);
let coneH = parseFloat(el('coneHRange').value);
function drawCone(r,h){
  coneSVG.innerHTML='';
  const W=560,H=320,ox=280,oy=220;
  const px=40;
  const R=r*px,Ht=h*px;
  const top={x:ox,y:oy-Ht};
  const baseL={x:ox-R,y:oy};
  const baseR={x:ox+R,y:oy};
  coneSVG.appendChild(createSVG('polygon',{points:`${top.x},${top.y} ${baseL.x},${baseL.y} ${baseR.x},${baseR.y}`,fill:'rgba(124,92,255,0.08)',stroke:'rgba(124,92,255,0.2)','stroke-width':2}));
  const l = Math.sqrt(r*r+h*h);
  el('coneL').textContent = l.toFixed(3);
  el('coneLformula').textContent = l.toFixed(3);
  const csa = Math.PI*r*l;
  const vol = (1/3)*Math.PI*r*r*h;
  el('coneCSA').textContent = csa.toFixed(3);
  el('coneVol').textContent = vol.toFixed(3);
  el('coneCSAformula').textContent = csa.toFixed(3);
  el('coneVformula').textContent = vol.toFixed(3);
  el('coneR').textContent = r.toFixed(2);
  el('coneH').textContent = h.toFixed(2);
  el('coneRVal').textContent = r.toFixed(2);
  el('coneHVal').textContent = h.toFixed(2);
  markDone('cone');
}
el('coneRRange').addEventListener('input', e=>{ coneR=parseFloat(e.target.value); drawCone(coneR,coneH); });
el('coneHRange').addEventListener('input', e=>{ coneH=parseFloat(e.target.value); drawCone(coneR,coneH); });
el('coneRotate').addEventListener('click', ()=>{ if(!isReducedMotion) anime({targets:'#coneSVG',rotate:[0,12,-8,0],duration:1200,easing:'easeInOutSine'}); });
el('unfoldCone').addEventListener('click', ()=>{ if(!isReducedMotion) anime({targets:'#coneSVG polygon',scale:[1,1.4],rotate:[0,20,-10,0],direction:'alternate',duration:900,easing:'easeInOutQuad'}); });
drawCone(coneR,coneH);

// Frustum
let frR=parseFloat(el('frRRange').value), frRbig=parseFloat(el('frRbigRange').value), frH=parseFloat(el('frHRange').value);
function drawFrustum(r,R,h){
  frustumSVG.innerHTML='';
  const W=560,H=320,ox=280,oy=220; const px=40;
  const rpx=r*px,Rpx=R*px,Hpx=h*px;
  const topL={x:ox-rpx,y:oy-Hpx};
  const topR={x:ox+rpx,y:oy-Hpx};
  const baseL={x:ox-Rpx,y:oy};
  const baseR={x:ox+Rpx,y:oy};
  frustumSVG.appendChild(createSVG('polygon',{points:`${topL.x},${topL.y} ${topR.x},${topR.y} ${baseR.x},${baseR.y} ${baseL.x},${baseL.y}`,fill:'rgba(124,92,255,0.08)',stroke:'rgba(124,92,255,0.2)','stroke-width':2}));
  const s = Math.sqrt(h*h+(R-r)*(R-r));
  el('frS').textContent=s.toFixed(3);
  el('frSformula').textContent=s.toFixed(3);
  const csa=Math.PI*(R+r)*s;
  const vol=(1/3)*Math.PI*h*(R*R+R*r+r*r);
  el('frCSA').textContent=csa.toFixed(3);
  el('frVol').textContent=vol.toFixed(3);
  el('frCSAformula').textContent=csa.toFixed(3);
  el('frVformula').textContent=vol.toFixed(3);
  el('frR').textContent=r.toFixed(2);
  el('frRbig').textContent=R.toFixed(2);
  el('frH').textContent=h.toFixed(2);
  el('frRval').textContent=r.toFixed(2);
  el('frRbigval').textContent=R.toFixed(2);
  el('frHval').textContent=h.toFixed(2);
  markDone('frustum');
}
el('frRRange').addEventListener('input', e=>{ frR=parseFloat(e.target.value); drawFrustum(frR,frRbig,frH); });
el('frRbigRange').addEventListener('input', e=>{ frRbig=parseFloat(e.target.value); drawFrustum(frR,frRbig,frH); });
el('frHRange').addEventListener('input', e=>{ frH=parseFloat(e.target.value); drawFrustum(frR,frRbig,frH); });
el('frRotate').addEventListener('click', ()=>{ if(!isReducedMotion) anime({targets:'#frustumSVG',rotate:[0,12,-10,0],duration:1200,easing:'easeInOutSine'}); });
el('sliceFrustum').addEventListener('click', ()=>{ if(!isReducedMotion) anime({targets:'#frustumSVG polygon',translateY:[0,-20,0],direction:'alternate',duration:700,easing:'easeInOutQuad'}); });
drawFrustum(frR,frRbig,frH);

// Application examples
el('solveTank').addEventListener('click', ()=>{
  const r=2,h=3;
  const V=Math.PI*r*r*h, TSA=2*Math.PI*r*(r+h);
  el('tankSolution').innerHTML=`Capacity (V)=${V.toFixed(2)} m³<br>Total Surface Area = ${TSA.toFixed(2)} m²`;
  markDone('apps');
});
el('resetTank').addEventListener('click', ()=>{ el('tankSolution').innerHTML=''; });

el('solveIce').addEventListener('click', ()=>{
  const r=3,h=4;
  const volCone=(1/3)*Math.PI*r*r*h, volHem=(2/3)*Math.PI*r*r*r;
  const totalV = volCone+volHem;
  el('iceSolution').innerHTML=`Volume of ice-cream = ${totalV.toFixed(2)} cm³`;
  markDone('apps');
});




});

/* Respect reduced motion: disable animations if requested */
if (isReducedMotion) {
  // disable anime.js heavy animations by overriding functions to no-op where necessary
}

/* Initial mark done for no-js debug */
updateProgressUI();

</script>
</body>
</html>
