<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chapter 12 — Surface Areas & Volumes (Class 10) — Interactive</title>

<!-- anime.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

<!-- minimal Tailwind-like utility (tiny) -->
<style>
  :root{
    --bg:#071026; --card:#072033cc; --muted:#98a8b3; --accent:#7c5cff; --accent2:#00d4ff;
    --success:#34d399; --danger:#fb7185;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,var(--bg),#02111b);color:#e6eef6;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;min-height:100vh}
  .app{display:flex;gap:16px;padding:18px}
  .sidebar{width:300px;flex:0 0 300px;position:sticky;top:18px;height:calc(100vh - 36px)}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(2,6,23,0.7)}
  .title{font-size:18px;font-weight:700;color:var(--accent)}
  .muted{color:var(--muted);font-size:13px}
  .nav{margin-top:12px;display:flex;flex-direction:column;gap:8px}
  .nav button{background:transparent;border:1px solid rgba(255,255,255,0.03);color:#cfe7ff;padding:10px;border-radius:8px;text-align:left;cursor:pointer}
  .nav button.active{background:linear-gradient(90deg, rgba(124,92,255,0.12), rgba(0,212,255,0.06));border-color:rgba(124,92,255,0.26)}
  main{flex:1;overflow:auto;padding-bottom:40px}
  section{margin-bottom:20px}
  .section-header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .h2{font-size:16px;color:var(--accent);font-weight:700}
  .desc{color:var(--muted);font-size:13px;margin-top:6px}
  .grid{display:grid;grid-template-columns:1fr 380px;gap:12px;margin-top:12px}
  .sim-area{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border-radius:10px;padding:12px;min-height:320px;border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden}
  .controls{display:flex;flex-direction:column;gap:10px}
  label{font-size:13px;color:#dbeafe;display:flex;flex-direction:column;gap:6px}
  input[type=range]{width:100%}
  .val{font-weight:700;color:var(--accent2)}
  .formula{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02);font-family:ui-monospace,monospace;color:#dbeafe}
  .bignum{font-size:20px;font-weight:700;color:#cfeffd}
  .btn{padding:8px 10px;border-radius:8px;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#001018;border:none;cursor:pointer}
  .secondary{background:transparent;border:1px solid rgba(255,255,255,0.04);color:#cfeffd}
  .footer{margin-top:8px;color:var(--muted);font-size:12px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:12px}
  .canvas-wrap{display:flex;align-items:center;justify-content:center;width:100%;height:340px;position:relative;overflow:visible}
  .stat{margin-top:10px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02);width:100%}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .hint{color:var(--muted);font-size:13px}
  
  /* Mobile responsiveness */
  @media (max-width:980px){
    .app{flex-direction:column;padding:12px}
    .sidebar{width:100%;height:auto;position:relative}
    .grid{grid-template-columns:1fr;gap:10px}
    .nav{flex-direction:row;flex-wrap:wrap}
    .nav button{flex:1 1 48%;min-width:140px}
    .canvas-wrap{height:280px}
    .sim-area{min-height:280px}
    #cuboidSVG, #sphereCanvas, #cylSVG, #coneSVG, #frustumSVG {
      max-width: 100%;
      height: auto;
    }
  }
  
  @media (max-width:600px){
    .app{padding:8px}
    .card{padding:10px}
    .nav button{flex:1 1 100%}
    .canvas-wrap{height:240px}
    .sim-area{min-height:240px}
    .grid{grid-template-columns:1fr}
    .section-header{flex-direction:column;align-items:flex-start}
    .badge{margin-top:8px}
  }
  
  @media (prefers-reduced-motion: reduce){
    *{animation:none!important;transition:none!important}
  }
  
  /* Simulation labels */
  .sim-label {
    position: absolute;
    background: rgba(7, 32, 51, 0.8);
    border: 1px solid rgba(124, 92, 255, 0.3);
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 12px;
    color: #cfeffd;
    pointer-events: none;
    z-index: 10;
  }
</style>
</head>
<body>
<div class="app">
  <!-- Sidebar -->
  <aside class="sidebar">
    <div class="card">
      <div class="title">Chapter 12 — Surface Areas & Volumes</div>
      <div class="muted" style="margin-top:6px">Class 10 NCERT — Interactive simulations. Move sliders, rotate shapes, see formulas update live. Built with <span class="badge">anime.js</span></div>
      <div class="nav" role="navigation" aria-label="Chapter sections" id="nav">
        <button data-target="cuboid" class="active">1 • Cubes & Cuboids</button>
        <button data-target="sphere">2 • Sphere</button>
        <button data-target="cylinder">3 • Cylinder</button>
        <button data-target="cone">4 • Cone</button>
        <button data-target="frustum">5 • Frustum</button>
        <button data-target="apps">6 • Applications & Problems</button>
      </div>

      <div style="margin-top:12px" class="muted">
        <div><strong>Progress:</strong> <span id="progressPct">0 / 6</span></div>
        <div class="footer">Saved locally. Respect reduced motion settings.</div>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px">
        <button id="resetProgress" class="secondary" style="flex:1">Reset Progress</button>
        <button id="downloadJSON" class="secondary" style="flex:1">Export Progress</button>
      </div>
    </div>
  </aside>

  <!-- Main -->
  <main>
    <!-- Cuboid -->
    <section id="cuboid" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Cubes & Cuboids</div>
          <div class="desc">Surface area (TSA) & Volume. Change length, breadth, height — watch shape animate and formulas update.</div>
        </div>
        <div class="badge">TSA = 2(lb + bh + hl) • V = lbh</div>
      </div>

      <div class="grid">
        <div class="sim-area">
          <div class="canvas-wrap">
            <svg id="cuboidSVG" width="560" height="320" viewBox="0 0 560 320" aria-label="Cuboid simulation" preserveAspectRatio="xMidYMid meet"></svg>
          </div>
          <div class="stat" id="cuboidStats" aria-live="polite">
            <div class="row"><div class="muted">Dimensions:</div><div class="val" id="dim-l">l=2.0</div><div class="val" id="dim-b">b=1.5</div><div class="val" id="dim-h">h=1.2</div></div>
            <div style="margin-top:8px" class="row"><div class="muted">TSA:</div><div class="bignum" id="cuboidTSA">—</div></div>
            <div class="row"><div class="muted">Volume:</div><div class="bignum" id="cuboidVol">—</div></div>
          </div>
        </div>

        <div class="controls card">
          <label>Length (l): <span class="val" id="lVal">2.0</span>
            <input id="lRange" type="range" min="0.5" max="4" step="0.1" value="2">
          </label>
          <label>Breadth (b): <span class="val" id="bVal">1.5</span>
            <input id="bRange" type="range" min="0.5" max="4" step="0.1" value="1.5">
          </label>
          <label>Height (h): <span class="val" id="hVal">1.2</span>
            <input id="hRange" type="range" min="0.5" max="4" step="0.1" value="1.2">
          </label>

          <div style="display:flex;gap:8px;margin-top:10px">
            <button id="cuboidRotate" class="btn">Rotate</button>
            <button id="cuboidExplode" class="secondary">Explode (faces)</button>
          </div>

          <div style="margin-top:12px">
            <div class="formula">TSA = 2(l b + b h + h l) = <span id="cuboidTSAformula">—</span></div>
            <div class="formula" style="margin-top:8px">V = l × b × h = <span id="cuboidVformula">—</span></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Sphere -->
    <section id="sphere" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Spheres</div>
          <div class="desc">Surface area & volume of a sphere. Try changing the radius and filling level.</div>
        </div>
        <div class="badge">SA = 4πr² • V = (4/3)πr³</div>
      </div>

      <div class="grid">
        <div class="sim-area">
          <div class="canvas-wrap">
            <canvas id="sphereCanvas" width="560" height="320" aria-label="Sphere"></canvas>
          </div>

          <div class="stat" id="sphereStats" aria-live="polite">
            <div class="row"><div class="muted">Radius: <span class="val" id="rVal">1.5</span> units</div></div>
            <div style="margin-top:8px" class="row"><div class="muted">Surface Area:</div><div class="bignum" id="sphereSA">—</div></div>
            <div class="row"><div class="muted">Volume:</div><div class="bignum" id="sphereVol">—</div></div>
          </div>
        </div>

        <div class="controls card">
          <label>Radius (r): <span class="val" id="rSliderVal">1.5</span>
            <input id="rRange" type="range" min="0.5" max="3" step="0.1" value="1.5">
          </label>

          <label>Fill %: <span class="val" id="fillVal">0%</span>
            <input id="fillRange" type="range" min="0" max="100" step="1" value="0">
          </label>

          <div style="margin-top:8px">
            <div class="formula">SA = 4π r² = <span id="sphereSAformula">—</span></div>
            <div class="formula" style="margin-top:8px">V = (4/3)π r³ = <span id="sphereVformula">—</span></div>
          </div>

          <div style="margin-top:12px" class="hint">Tip: Fill % animates a liquid level inside the sphere to visualize volume fraction.</div>
        </div>
      </div>
    </section>

    <!-- Cylinder -->
    <section id="cylinder" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Right Circular Cylinder</div>
          <div class="desc">Curved surface area (CSA), total surface area & volume. Try unrolling the lateral surface.</div>
        </div>
        <div class="badge">CSA = 2π r h • TSA = 2π r (r + h)</div>
      </div>

      <div class="grid">
        <div class="sim-area">
          <div class="canvas-wrap">
            <svg id="cylSVG" width="560" height="320" viewBox="0 0 560 320" aria-label="Cylinder" preserveAspectRatio="xMidYMid meet"></svg>
          </div>
          <div class="stat" id="cylStats" aria-live="polite">
            <div class="row"><div class="muted">Radius:</div><div class="val" id="cylR">1.0</div><div class="muted">Height:</div><div class="val" id="cylH">2.0</div></div>
            <div style="margin-top:8px" class="row"><div class="muted">CSA:</div><div class="bignum" id="cylCSA">—</div></div>
            <div class="row"><div class="muted">Volume:</div><div class="bignum" id="cylVol">—</div></div>
          </div>
        </div>

        <div class="controls card">
          <label>Radius (r): <span class="val" id="cylRVal">1.0</span>
            <input id="cylRRange" type="range" min="0.5" max="3" step="0.1" value="1">
          </label>
          <label>Height (h): <span class="val" id="cylHVal">2.0</span>
            <input id="cylHRange" type="range" min="0.5" max="5" step="0.1" value="2">
          </label>

          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="unrollCyl" class="btn">Unroll Lateral Surface</button>
            <button id="cylRotate" class="secondary">Rotate</button>
          </div>

          <div style="margin-top:12px">
            <div class="formula">CSA = 2π r h = <span id="cylCSAformula">—</span></div>
            <div class="formula" style="margin-top:8px">V = π r² h = <span id="cylVformula">—</span></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Cone -->
    <section id="cone" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Cone</div>
          <div class="desc">Curved surface area & volume. Unfold curved surface to a sector to understand CSA.</div>
        </div>
        <div class="badge">CSA = π r l • V = (1/3)π r² h</div>
      </div>

      <div class="grid">
        <div class="sim-area">
          <div class="canvas-wrap">
            <svg id="coneSVG" width="560" height="320" viewBox="0 0 560 320" aria-label="Cone" preserveAspectRatio="xMidYMid meet"></svg>
          </div>
          <div class="stat" id="coneStats" aria-live="polite">
            <div class="row"><div class="muted">Radius:</div><div class="val" id="coneR">1.0</div><div class="muted">Height:</div><div class="val" id="coneH">2.0</div></div>
            <div style="margin-top:8px" class="row"><div class="muted">Slant height (l):</div><div class="bignum" id="coneL">—</div></div>
            <div class="row"><div class="muted">CSA:</div><div class="bignum" id="coneCSA">—</div></div>
            <div class="row"><div class="muted">Volume:</div><div class="bignum" id="coneVol">—</div></div>
          </div>
        </div>

        <div class="controls card">
          <label>Radius (r): <span class="val" id="coneRVal">1.0</span>
            <input id="coneRRange" type="range" min="0.5" max="3" step="0.1" value="1">
          </label>
          <label>Height (h): <span class="val" id="coneHVal">2.0</span>
            <input id="coneHRange" type="range" min="0.5" max="5" step="0.1" value="2">
          </label>

          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="unfoldCone" class="btn">Unfold Curved Surface</button>
            <button id="coneRotate" class="secondary">Rotate</button>
          </div>

          <div style="margin-top:12px">
            <div class="formula">l = √(r² + h²) = <span id="coneLformula">—</span></div>
            <div class="formula" style="margin-top:8px">CSA = π r l = <span id="coneCSAformula">—</span></div>
            <div class="formula" style="margin-top:8px">V = (1/3)π r² h = <span id="coneVformula">—</span></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Frustum -->
    <section id="frustum" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Frustum of a Cone</div>
          <div class="desc">Curved surface area and volume of frustum formed by slicing a cone.</div>
        </div>
        <div class="badge">V = (1/3)π h (R² + Rr + r²) • CSA = π (R + r) s</div>
      </div>

      <div class="grid">
        <div class="sim-area">
          <div class="canvas-wrap">
            <svg id="frustumSVG" width="560" height="320" viewBox="0 0 560 320" aria-label="Frustum" preserveAspectRatio="xMidYMid meet"></svg>
          </div>
          <div class="stat" id="frustumStats" aria-live="polite">
            <div class="row"><div class="muted">Top r:</div><div class="val" id="frR">0.8</div><div class="muted">Bottom R:</div><div class="val" id="frRbig">2.0</div><div class="muted">Height h:</div><div class="val" id="frH">2.0</div></div>
            <div style="margin-top:8px" class="row"><div class="muted">Slant (s):</div><div class="bignum" id="frS">—</div></div>
            <div class="row"><div class="muted">CSA:</div><div class="bignum" id="frCSA">—</div></div>
            <div class="row"><div class="muted">Volume:</div><div class="bignum" id="frVol">—</div></div>
          </div>
        </div>

        <div class="controls card">
          <label>Top radius (r): <span class="val" id="frRval">0.8</span>
            <input id="frRRange" type="range" min="0.2" max="2.5" step="0.1" value="0.8">
          </label>
          <label>Bottom radius (R): <span class="val" id="frRbigval">2.0</span>
            <input id="frRbigRange" type="range" min="0.5" max="3" step="0.1" value="2.0">
          </label>
          <label>Height (h): <span class="val" id="frHval">2.0</span>
            <input id="frHRange" type="range" min="0.5" max="4" step="0.1" value="2.0">
          </label>

          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="sliceFrustum" class="btn">Slice from Cone</button>
            <button id="frRotate" class="secondary">Rotate</button>
          </div>

          <div style="margin-top:12px">
            <div class="formula">s = √(h² + (R − r)²) = <span id="frSformula">—</span></div>
            <div class="formula" style="margin-top:8px">CSA = π (R + r) s = <span id="frCSAformula">—</span></div>
            <div class="formula" style="margin-top:8px">V = (1/3)π h (R² + Rr + r²) = <span id="frVformula">—</span></div>
          </div>
        </div>
      </div>
    </section>

    <!-- Applications -->
    <section id="apps" class="card section" tabindex="0">
      <div class="section-header">
        <div>
          <div class="h2">Applications & Problems</div>
          <div class="desc">Real-world problems: water tank (cylinder), ice-cream cone (cone+hemisphere), dome (hemisphere).</div>
        </div>
        <div class="badge">Solve step-by-step. Click examples to view worked solution.</div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px">
        <div class="card" style="padding:12px">
          <div style="font-weight:700">Example 1 — Water Tank</div>
          <div class="muted" style="margin-top:6px">A cylindrical tank radius 2m and height 3m. Find capacity and total surface area.</div>
          <div style="margin-top:10px;display:flex;gap:8px">
            <button class="btn" id="solveTank">Show solution</button>
            <button class="secondary" id="resetTank">Reset</button>
          </div>
          <div id="tankSolution" style="margin-top:10px;color:var(--muted)"></div>
        </div>

        <div class="card" style="padding:12px">
          <div style="font-weight:700">Example 2 — Ice-cream Cone</div>
          <div class="muted" style="margin-top:6px">Cone radius 3cm height 4cm with hemisphere of radius 3cm. Find volume.</div>
          <div style="margin-top:10px;display:flex;gap:8px">
            <button class="btn" id="solveIce">Show solution</button>
          </div>
          <div id="iceSolution" style="margin-top:10px;color:var(--muted)"></div>
        </div>
      </div>
    </section>

    <div style="height:60px"></div>
  </main>
</div>

<script>
/*
  Interactive Chapter 12 SPA
  - Uses anime.js for animations
  - Draws shapes in SVG / Canvas and updates formulas live
  - Saves progress to localStorage
  - Respects prefers-reduced-motion
*/

// Utilities
const el = id => document.getElementById(id);
const clamp = (v,min,max) => Math.max(min, Math.min(max, v));
const saved = (k, def) => {
  try { const s = JSON.parse(localStorage.getItem('ch12_'+k)); return s ?? def } catch(e) { return def }
};
const save = (k,v) => localStorage.setItem('ch12_'+k, JSON.stringify(v));
const isReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

// Progress tracking
let completed = saved('completed', {});
function markDone(section) { completed[section]=true; save('completed', completed); updateProgressUI(); }
function updateProgressUI(){
  const total = 6;
  const done = Object.keys(completed).length;
  el('progressPct').textContent = done + ' / ' + total;
}
updateProgressUI();

// NAV: scroll to section behavior + active class
document.querySelectorAll('.nav button').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const tgt = btn.dataset.target;
    document.getElementById(tgt).scrollIntoView({behavior: isReducedMotion ? 'auto' : 'smooth', block:'start'});
    document.querySelectorAll('.nav button').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
  });
});

// Reset & export
el('resetProgress').textContent = 'Reset Progress';
el('downloadJSON').textContent = 'Export Progress';
el('resetProgress').addEventListener('click', ()=>{
  if (!confirm('Reset saved progress?')) return;
  localStorage.clear();
  completed = {};
  updateProgressUI();
  location.reload();
});
el('downloadJSON').addEventListener('click', ()=>{
  const data = {completed, timestamp: new Date().toISOString()};
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='ch12-progress.json'; a.click();
});

/* --------------------
   CUBOID (SVG drawing & interactions)
   -------------------- */
const cuboidSVG = el('cuboidSVG');
const NS = "http://www.w3.org/2000/svg";
function createSVG(tag, attrs){
  const node = document.createElementNS(NS, tag);
  for(const k in attrs) node.setAttribute(k, attrs[k]);
  return node;
}

function drawCuboid(l,b,h, opts={rotate:0}){
  cuboidSVG.innerHTML = '';
  const W = 560, H = 320;
  
  // Calculate scaling to fit within container
  const maxDimension = Math.max(l, b, h);
  const scale = Math.min(W, H) * 0.3 / maxDimension;
  
  const ox = W/2, oy = H/2;
  
  // Calculate points for cuboid with proper scaling
  const A = {x:ox - l*scale/2, y:oy + h*scale/2};
  const B = {x:ox + l*scale/2, y:oy + h*scale/2};
  const C = {x:ox + l*scale/2, y:oy - h*scale/2};
  const D = {x:ox - l*scale/2, y:oy - h*scale/2};
  
  // Offset for depth (breadth)
  const dx = b*scale*0.5;
  const dy = -b*scale*0.3;
  const A2 = {x:A.x + dx, y: A.y + dy};
  const B2 = {x:B.x + dx, y: B.y + dy};
  const C2 = {x:C.x + dx, y: C.y + dy};
  const D2 = {x:D.x + dx, y: D.y + dy};

  // Draw faces
  // Back face
  cuboidSVG.appendChild(createSVG('polygon',{
    points:`${A2.x},${A2.y} ${B2.x},${B2.y} ${C2.x},${C2.y} ${D2.x},${D2.y}`,
    fill:'rgba(124,92,255,0.08)', stroke:'rgba(124,92,255,0.18)', 'stroke-width':1
  }));
  
  // Top face
  cuboidSVG.appendChild(createSVG('polygon',{
    points:`${D2.x},${D2.y} ${C2.x},${C2.y} ${C.x},${C.y} ${D.x},${D.y}`,
    fill:'rgba(0,212,255,0.06)', stroke:'rgba(0,212,255,0.12)', 'stroke-width':1
  }));
  
  // Front face
  cuboidSVG.appendChild(createSVG('polygon',{
    points:`${A.x},${A.y} ${B.x},${B.y} ${C.x},${C.y} ${D.x},${D.y}`,
    fill:'rgba(255,255,255,0.02)', stroke:'rgba(255,255,255,0.06)', 'stroke-width':1
  }));
  
  // Side face
  cuboidSVG.appendChild(createSVG('polygon',{
    points:`${B.x},${B.y} ${B2.x},${B2.y} ${C2.x},${C2.y} ${C.x},${C.y}`,
    fill:'rgba(124,92,255,0.04)', stroke:'rgba(124,92,255,0.12)', 'stroke-width':1
  }));

  // Add dimension labels
  addDimensionLabel(cuboidSVG, A, B, "l = " + l.toFixed(1));
  addDimensionLabel(cuboidSVG, B, C, "h = " + h.toFixed(1));
  addDimensionLabel(cuboidSVG, B, B2, "b = " + b.toFixed(1));

  // Update stats
  const tsa = 2*(l*b + b*h + h*l);
  const vol = l*b*h;
  el('cuboidTSA').textContent = tsa.toFixed(3);
  el('cuboidVol').textContent = vol.toFixed(3);
  el('cuboidTSAformula').textContent = tsa.toFixed(3);
  el('cuboidVformula').textContent = vol.toFixed(3);
  el('dim-l').textContent = 'l=' + l.toFixed(2);
  el('dim-b').textContent = 'b=' + b.toFixed(2);
  el('dim-h').textContent = 'h=' + h.toFixed(2);
  markDone('cuboid');
}

// Helper function to add dimension labels
function addDimensionLabel(svg, p1, p2, text) {
  const midX = (p1.x + p2.x) / 2;
  const midY = (p1.y + p2.y) / 2;
  
  const label = createSVG('text', {
    x: midX,
    y: midY,
    fill: '#cfeffd',
    'font-size': '12px',
    'text-anchor': 'middle',
    'alignment-baseline': 'middle'
  });
  label.textContent = text;
  svg.appendChild(label);
}

// Initial cuboid state
let L = parseFloat(el('lRange').value);
let B = parseFloat(el('bRange').value);
let H = parseFloat(el('hRange').value);

function updateCuboidUI(){
  el('lVal').textContent = L.toFixed(1);
  el('bVal').textContent = B.toFixed(1);
  el('hVal').textContent = H.toFixed(1);
  drawCuboid(L,B,H);
}
el('lRange').addEventListener('input', e=>{ L = parseFloat(e.target.value); updateCuboidUI();});
el('bRange').addEventListener('input', e=>{ B = parseFloat(e.target.value); updateCuboidUI();});
el('hRange').addEventListener('input', e=>{ H = parseFloat(e.target.value); updateCuboidUI();});

el('cuboidRotate').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  anime({
    targets: '#cuboidSVG',
    rotate: [0, 15, -10, 0],
    duration: 1200,
    easing: 'easeInOutSine'
  });
});

el('cuboidExplode').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  anime({
    targets: '#cuboidSVG polygon',
    translateX: (el, i) => (i%2===0? -10 : 10),
    translateY: (el, i) => (i%2===0? -6 : 6),
    duration: 700,
    direction:'alternate',
    easing:'easeInOutQuad'
  });
});
updateCuboidUI();

/* --------------------
   SPHERE (Canvas drawing, fill animation)
   -------------------- */
const sphereCanvas = el('sphereCanvas');
const sCtx = sphereCanvas.getContext('2d');
let r = parseFloat(el('rRange').value);
let fillPct = parseInt(el('fillRange').value,10);

function drawSphere(){
  const W = sphereCanvas.width, H = sphereCanvas.height;
  sCtx.clearRect(0,0,W,H);
  
  // Center and scale
  const cx = W/2, cy = H/2;
  const maxRadius = Math.min(W, H) * 0.4;
  const rad = r * maxRadius / 3; // Scale to fit
  
  // Draw gradient sphere
  const grad = sCtx.createRadialGradient(cx - rad*0.3, cy - rad*0.4, rad*0.1, cx, cy, rad);
  grad.addColorStop(0, 'rgba(255,255,255,0.9)');
  grad.addColorStop(0.5, 'rgba(124,92,255,0.6)');
  grad.addColorStop(1, 'rgba(0,212,255,0.12)');
  sCtx.fillStyle = grad;
  sCtx.beginPath(); 
  sCtx.arc(cx, cy, rad, 0, Math.PI*2); 
  sCtx.fill();

  // Outline
  sCtx.strokeStyle = 'rgba(255,255,255,0.06)';
  sCtx.lineWidth = 2; 
  sCtx.beginPath(); 
  sCtx.arc(cx,cy,rad,0,Math.PI*2); 
  sCtx.stroke();

  // Draw fill (liquid)
  if (fillPct > 0) {
    const frac = fillPct / 100;
    const R = rad;
    let hcap = 0;
    
    // Approximate cap height for volume fraction
    if (frac <= 0.5) {
      // For lower half, use spherical cap formula
      hcap = R * (1 - Math.cos(Math.PI * frac));
    } else {
      // For upper half, invert the calculation
      hcap = R * (1 + Math.cos(Math.PI * (1 - frac)));
    }
    
    const clipY = cy - R + hcap;
    sCtx.save();
    sCtx.beginPath();
    sCtx.rect(0, clipY, W, H - clipY);
    sCtx.clip();
    
    const lg = sCtx.createLinearGradient(0, clipY, 0, H);
    lg.addColorStop(0, 'rgba(0,200,255,0.35)');
    lg.addColorStop(1, 'rgba(0,60,120,0.15)');
    sCtx.fillStyle = lg;
    sCtx.beginPath(); 
    sCtx.arc(cx, cy, R, 0, Math.PI*2); 
    sCtx.fill();
    sCtx.restore();
  }

  // Add radius label
  sCtx.fillStyle = '#cfeffd';
  sCtx.font = '14px Arial';
  sCtx.fillText(`r = ${r.toFixed(1)}`, cx - 20, cy + rad + 20);

  // Update stats
  const sa = 4*Math.PI*Math.pow(r,2);
  const vol = 4/3*Math.PI*Math.pow(r,3);
  el('sphereSA').textContent = sa.toFixed(3);
  el('sphereVol').textContent = vol.toFixed(3);
  el('sphereSAformula').textContent = sa.toFixed(3);
  el('sphereVformula').textContent = vol.toFixed(3);
  el('rVal').textContent = r.toFixed(2);
  el('rSliderVal').textContent = r.toFixed(2);
  el('fillVal').textContent = fillPct + '%';
  markDone('sphere');
}

el('rRange').addEventListener('input', e=>{ r = parseFloat(e.target.value); drawSphere(); });
el('fillRange').addEventListener('input', e=>{ 
  fillPct = parseInt(e.target.value,10); 
  if (!isReducedMotion) {
    anime({
      targets: {v: fillPct},
      v: fillPct,
      round: 1,
      duration: 800,
      easing: 'easeInOutCubic',
      update: anim => {
        fillPct = anim.animations[0].currentValue;
        drawSphere();
      }
    });
  } else {
    drawSphere();
  }
});
drawSphere();

/* --------------------
   Cylinder (SVG) + unroll animation
   -------------------- */
const cylSVG = el('cylSVG');

function drawCylinder(r,h){
  cylSVG.innerHTML = '';
  const W = 560, H = 320;
  
  // Calculate scaling
  const maxDimension = Math.max(r*2, h);
  const scale = Math.min(W, H) * 0.3 / maxDimension;
  
  const cx = W/2, cy = H/2;
  const R = r*scale, Ht = h*scale;
  
  // Top ellipse
  cylSVG.appendChild(createSVG('ellipse',{
    cx:cx, cy:cy - Ht/2, rx:R, ry:R*0.3,
    fill:'rgba(124,92,255,0.08)', stroke:'rgba(124,92,255,0.18)', 'stroke-width':2
  }));
  
  // Body
  const body = createSVG('rect',{
    x:cx-R, y:cy-Ht/2, width:R*2, height:Ht,
    fill:'rgba(0,212,255,0.02)', stroke:'rgba(0,212,255,0.1)', 'stroke-width':2
  });
  cylSVG.appendChild(body);
  
  // Bottom ellipse
  cylSVG.appendChild(createSVG('ellipse',{
    cx:cx, cy:cy + Ht/2, rx:R, ry:R*0.3,
    fill:'rgba(0,212,255,0.03)', stroke:'rgba(0,212,255,0.1)', 'stroke-width':2
  }));
  
  // Add dimension labels
  addDimensionLabel(cylSVG, {x:cx, y:cy-Ht/2}, {x:cx+R, y:cy-Ht/2}, "r = " + r.toFixed(1));
  addDimensionLabel(cylSVG, {x:cx+R, y:cy-Ht/2}, {x:cx+R, y:cy+Ht/2}, "h = " + h.toFixed(1));
  
  // Update stats
  const csa = 2*Math.PI*r*h;
  const vol = Math.PI*r*r*h;
  el('cylCSA').textContent = csa.toFixed(3);
  el('cylVol').textContent = vol.toFixed(3);
  el('cylCSAformula').textContent = csa.toFixed(3);
  el('cylVformula').textContent = vol.toFixed(3);
  el('cylR').textContent = r.toFixed(2);
  el('cylH').textContent = h.toFixed(2);
  el('cylRVal').textContent = r.toFixed(2);
  el('cylHVal').textContent = h.toFixed(2);
  markDone('cylinder');
}

let cylR = parseFloat(el('cylRRange').value);
let cylH = parseFloat(el('cylHRange').value);

function updateCylinderUI(){
  cylR = parseFloat(el('cylRRange').value);
  cylH = parseFloat(el('cylHRange').value);
  drawCylinder(cylR,cylH);
}
el('cylRRange').addEventListener('input', updateCylinderUI);
el('cylHRange').addEventListener('input', updateCylinderUI);

el('unrollCyl').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  anime({
    targets: '#cylSVG rect',
    scaleX: [1, 1.5],
    duration: 800,
    direction: 'alternate',
    easing: 'easeInOutQuad'
  });
});

el('cylRotate').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  anime({
    targets: '#cylSVG',
    rotate: [0, 15, -10, 0],
    duration: 1200,
    easing: 'easeInOutSine'
  });
});
updateCylinderUI();

/* --------------------
   CONE (SVG) + unfold
   -------------------- */
const coneSVG = el('coneSVG');

function drawCone(r,h){
  coneSVG.innerHTML = '';
  const W = 560, H = 320;
  
  // Calculate scaling
  const l = Math.sqrt(r*r + h*h);
  const maxDimension = Math.max(r*2, h, l);
  const scale = Math.min(W, H) * 0.3 / maxDimension;
  
  const cx = W/2, cy = H/2 + 40; // Offset slightly downward
  const R = r*scale, Ht = h*scale;
  
  // Base ellipse
  coneSVG.appendChild(createSVG('ellipse',{
    cx:cx, cy:cy, rx:R, ry:R*0.3,
    fill:'rgba(0,212,255,0.03)', stroke:'rgba(0,212,255,0.1)', 'stroke-width':2
  }));
  
  // Cone sides
  const apexX = cx, apexY = cy - Ht;
  const leftX = cx - R, rightX = cx + R;
  
  const conePath = createSVG('path',{
    d: `M ${leftX} ${cy} L ${apexX} ${apexY} L ${rightX} ${cy} Z`,
    fill:'rgba(124,92,255,0.08)', stroke:'rgba(124,92,255,0.18)', 'stroke-width':2
  });
  coneSVG.appendChild(conePath);
  
  // Add dimension labels
  addDimensionLabel(coneSVG, {x:cx, y:cy}, {x:cx+R, y:cy}, "r = " + r.toFixed(1));
  addDimensionLabel(coneSVG, {x:cx, y:cy}, {x:cx, y:cy-Ht}, "h = " + h.toFixed(1));
  
  // Calculate and display slant height
  const slant = Math.sqrt(r*r + h*h);
  addDimensionLabel(coneSVG, {x:cx, y:cy-Ht}, {x:cx+R, y:cy}, "l = " + slant.toFixed(1));
  
  // Update stats
  const csa = Math.PI * r * slant;
  const vol = (1/3) * Math.PI * r*r * h;
  el('coneL').textContent = slant.toFixed(3);
  el('coneCSA').textContent = csa.toFixed(3);
  el('coneVol').textContent = vol.toFixed(3);
  el('coneLformula').textContent = slant.toFixed(3);
  el('coneCSAformula').textContent = csa.toFixed(3);
  el('coneVformula').textContent = vol.toFixed(3);
  el('coneR').textContent = r.toFixed(2);
  el('coneH').textContent = h.toFixed(2);
  el('coneRVal').textContent = r.toFixed(2);
  el('coneHVal').textContent = h.toFixed(2);
  markDone('cone');
}

let coneR = parseFloat(el('coneRRange').value);
let coneH = parseFloat(el('coneHRange').value);

function updateConeUI(){
  coneR = parseFloat(el('coneRRange').value);
  coneH = parseFloat(el('coneHRange').value);
  drawCone(coneR,coneH);
}
el('coneRRange').addEventListener('input', updateConeUI);
el('coneHRange').addEventListener('input', updateConeUI);

el('unfoldCone').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  anime({
    targets: '#coneSVG path',
    scale: [1, 1.2],
    rotate: [0, 10],
    duration: 800,
    direction: 'alternate',
    easing: 'easeInOutQuad'
  });
});

el('coneRotate').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  anime({
    targets: '#coneSVG',
    rotate: [0, 15, -10, 0],
    duration: 1200,
    easing: 'easeInOutSine'
  });
});
updateConeUI();

/* --------------------
   FRUSTUM
   -------------------- */
const frustumSVG = el('frustumSVG');

function drawFrustum(rSmall, rBig, h){
  frustumSVG.innerHTML = '';
  const W = 560, H = 320;
  
  // Calculate scaling
  const s = Math.sqrt(h*h + (rBig - rSmall)*(rBig - rSmall));
  const maxDimension = Math.max(rBig*2, h, s);
  const scale = Math.min(W, H) * 0.3 / maxDimension;
  
  const cx = W/2, cy = H/2;
  const r1 = rSmall*scale, r2 = rBig*scale, Ht = h*scale;
  
  // Top ellipse
  frustumSVG.appendChild(createSVG('ellipse',{
    cx:cx, cy:cy - Ht/2, rx:r1, ry:r1*0.3,
    fill:'rgba(255,255,255,0.02)', stroke:'rgba(255,255,255,0.04)', 'stroke-width':2
  }));
  
  // Bottom ellipse
  frustumSVG.appendChild(createSVG('ellipse',{
    cx:cx, cy:cy + Ht/2, rx:r2, ry:r2*0.3,
    fill:'rgba(0,212,255,0.03)', stroke:'rgba(0,212,255,0.1)', 'stroke-width':2
  }));
  
  // Frustum sides
  const topLeft = cx - r1, topRight = cx + r1;
  const bottomLeft = cx - r2, bottomRight = cx + r2;
  
  const frustumPath = createSVG('path',{
    d: `M ${topLeft} ${cy - Ht/2} L ${bottomLeft} ${cy + Ht/2} L ${bottomRight} ${cy + Ht/2} L ${topRight} ${cy - Ht/2} Z`,
    fill:'rgba(124,92,255,0.08)', stroke:'rgba(124,92,255,0.18)', 'stroke-width':2
  });
  frustumSVG.appendChild(frustumPath);
  
  // Add dimension labels
  addDimensionLabel(frustumSVG, {x:cx, y:cy-Ht/2}, {x:cx+r1, y:cy-Ht/2}, "r = " + rSmall.toFixed(1));
  addDimensionLabel(frustumSVG, {x:cx, y:cy+Ht/2}, {x:cx+r2, y:cy+Ht/2}, "R = " + rBig.toFixed(1));
  addDimensionLabel(frustumSVG, {x:cx+r2, y:cy-Ht/2}, {x:cx+r2, y:cy+Ht/2}, "h = " + h.toFixed(1));
  
  // Update stats
  const csa = Math.PI * (rBig + rSmall) * s;
  const vol = (1/3) * Math.PI * h * (rBig*rBig + rBig*rSmall + rSmall*rSmall);
  el('frS').textContent = s.toFixed(3);
  el('frCSA').textContent = csa.toFixed(3);
  el('frVol').textContent = vol.toFixed(3);
  el('frSformula').textContent = s.toFixed(3);
  el('frCSAformula').textContent = csa.toFixed(3);
  el('frVformula').textContent = vol.toFixed(3);
  el('frR').textContent = rSmall.toFixed(2);
  el('frRbig').textContent = rBig.toFixed(2);
  el('frH').textContent = h.toFixed(2);
  el('frRval').textContent = rSmall.toFixed(2);
  el('frRbigval').textContent = rBig.toFixed(2);
  el('frHval').textContent = h.toFixed(2);
  markDone('frustum');
}

let frR = parseFloat(el('frRRange').value);
let frRbig = parseFloat(el('frRbigRange').value);
let frH = parseFloat(el('frHRange').value);

function updateFrustumUI(){
  frR = parseFloat(el('frRRange').value);
  frRbig = parseFloat(el('frRbigRange').value);
  frH = parseFloat(el('frHRange').value);
  drawFrustum(frR, frRbig, frH);
}
el('frRRange').addEventListener('input', updateFrustumUI);
el('frRbigRange').addEventListener('input', updateFrustumUI);
el('frHRange').addEventListener('input', updateFrustumUI);

el('sliceFrustum').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  
  // Create a slicing line animation
  const line = createSVG('line', {
    x1: 100, y1: 160,
    x2: 460, y2: 160,
    stroke: 'rgba(0,212,255,0.8)',
    'stroke-width': 3,
    'stroke-dasharray': '10,5',
    opacity: 0
  });
  frustumSVG.appendChild(line);
  
  anime({
    targets: line,
    opacity: [0, 1],
    duration: 500,
    easing: 'easeOutCubic',
    complete: () => {
      setTimeout(() => {
        anime({
          targets: line,
          opacity: [1, 0],
          duration: 500,
          easing: 'easeInCubic',
          complete: () => line.remove()
        });
      }, 1000);
    }
  });
});

el('frRotate').addEventListener('click', ()=>{
  if (isReducedMotion) return;
  anime({
    targets: '#frustumSVG',
    rotate: [0, 15, -10, 0],
    duration: 1200,
    easing: 'easeInOutSine'
  });
});
updateFrustumUI();

/* --------------------
   Applications — Solutions for examples
   -------------------- */
el('solveTank').addEventListener('click', ()=>{
  const r = 2, h = 3; // meters
  const vol = Math.PI * r*r * h; // cubic meters
  const tsa = 2 * Math.PI * r * (r + h);
  el('tankSolution').innerHTML = `<div>Capacity (Volume) = π r² h = π × ${r}² × ${h} = ${vol.toFixed(3)} m³</div><div style="margin-top:6px">Total surface area = 2π r (r + h) = ${tsa.toFixed(3)} m²</div>`;
  markDone('apps');
});

el('resetTank').addEventListener('click', ()=>{
  el('tankSolution').innerHTML = '';
});

el('solveIce').addEventListener('click', ()=>{
  const r = 3, h = 4; // cm
  const volCone = (1/3) * Math.PI * r*r * h;
  const volSphereHalf = (2/3) * Math.PI * Math.pow(r,3);
  const total = volCone + volSphereHalf;
  el('iceSolution').innerHTML = `<div>Cone volume = (1/3)π r² h = ${(volCone).toFixed(2)} cm³</div>
    <div style="margin-top:6px">Hemisphere volume = (2/3)π r³ = ${(volSphereHalf).toFixed(2)} cm³</div>
    <div style="margin-top:8px"><strong>Total = ${total.toFixed(2)} cm³</strong></div>`;
  markDone('apps');
});

// Keyboard navigation
document.addEventListener('keydown', e=>{
  if (e.ctrlKey || e.metaKey) return;
  const key = e.key;
  if (key >= '1' && key <= '6') {
    const idx = parseInt(key,10)-1;
    const btns = Array.from(document.querySelectorAll('.nav button'));
    if (btns[idx]) btns[idx].click();
  }
});

// Accessibility - mark sections as visited when focused
document.querySelectorAll('.section').forEach(s=>{
  s.addEventListener('focusin', ()=> {
    markDone(s.id);
  });
});

// Initial setup
updateProgressUI();

</script>
</body>
</html>
